# This script relies on the Box Python SDK with JWT authentication:
# pip install "boxsdk[jwt]"

import json
import os
import time
import datetime
import hashlib

# pip install requests
from requests import ReadTimeout, ConnectTimeout, HTTPError, Timeout, ConnectionError

from boxsdk import JWTAuth
from boxsdk import Client
from boxsdk.exception import BoxAPIException

# This prevents BoxAPIException from outputting a detailed error message
from logging.handlers import SysLogHandler, logging
logging.basicConfig(level=logging.CRITICAL)

# Colors for formatting text output in Terminal
class colors:
	END = '\033[0m'
	BLUE = '\033[94m'
	GREEN = '\033[92m'
	YELLOW = '\033[33m'
	RED = '\033[31m'
	BOLD = '\033[1m'
	UNDERLINE = '\033[4m'

GB_BYTES = 1073741824 # 1gb in bytes

# Set the variables below if you want to hard-code your script
# uploader_id = '' # ID for the app user that will perform the upload
# target_folder_id = '' # ID for the overall parent folder where you are uploading
# s_input_folder = '' # path to the local folder where your files are stored

ignored_files_and_folders = ['.DS_Store', '.Trash', '.Spotlight-V100', '_gsdata_'] # Mac hidden files

counts = {"files_uploaded": 0,
	"files_existing": 0,
	"folders_created": 0,
	"folders_existing":0,
	"skipped": 0,
	"errors": 0,
	"oversize": 0}
	
def get_config():
	# Either load the existing config file or create a new one
	try:
		# Get the config file
		config_file = open('config.json')
		config = json.load(config_file)
		print(f"\n{colors.BOLD}Config file loaded!{colors.END}")
	except:
		# Config file does not exist
		print(f"\n{colors.BOLD}It looks like the config file doesn't exist. Let's create a new one.{colors.END}\n\nNOTE: Most of the information we need is available in a JSON file downloaded from the Box Developer console when you set up an app configuration or add a new public/private key pair.\n")
		
		json_file_path = input("Path to the JSON file generated by Box? ").replace("\ ", " ").rstrip()
		
		try:
			json_file = open(json_file_path)
			info = json.load(json_file)
		except:
			raise SystemExit(f"{colors.RED}Unable to open file at {json_file_path}{colors.END}\n")
		
		config = {}
		
		config['clientID'] = info['boxAppSettings']['clientID']
		config['clientSecret'] = info['boxAppSettings']['clientSecret']
		config['publicKeyID'] = info['boxAppSettings']['appAuth']['publicKeyID']
		config['passphrase'] = info['boxAppSettings']['appAuth']['passphrase']
		config['enterpriseID'] = info['enterpriseID']

		private_key_raw = info['boxAppSettings']['appAuth']['privateKey']
		
		app_user_count = input("\nHow many app users do you want to add? ").rstrip()

		try:
			app_user_count = int(app_user_count)
		except Exception as error:
			raise SystemExit(f"{colors.RED}Please enter a whole number!{colors.END}\n")
		
		config['appUsers'] = {}
		
		for x in range(app_user_count):
			config['appUsers'][x+1] = input(f"ID for app user #{x+1}? ").rstrip()
		
		print("\nThis script automatically uploads log files to a folder on Box. Make sure that your app users have access to that folder or they won't be able to upload the log.\n")
		config['logFileID'] = input("ID for the log folder on Box? ").rstrip()
		
		print("\nYou can also configure how often the log files upload based on number of lines.\n")
		config['logBatch'] = input("How often do you want to upload logs? (Default is every 5000 lines) ").rstrip() or 5000
		
		print("\nBox has different file size limits depending on your license and/or enterprise agreement. Look under your Account Details for a Max File Size.\n")
		max_file_gb = input("Maximum file size in gigabytes? ").rstrip()
		
		try:
			config["boxSizeLimitGB"] = int(max_file_gb)
			config["boxSizeLimitBytes"] = int(max_file_gb) * GB_BYTES
		except:
			raise SystemExit(f"{colors.RED}Please enter numbers only!{colors.END}\n")
			
		print("\nThis script is configured to automatically retry API requests.\n")
		config['maxAttempts'] = input("How many times do you want to retry requests? (Default is 10 times) ").rstrip() or 10
		
		print("\nIf the script has trouble connecting, it will wait a set amount of time before trying again.\n")
		config['timeToWait'] = input("How long do you want to wait in seconds? (Default is 30 seconds) ").rstrip() or 30
		
		print("\nPlease provide a secure folder location to store your private key.\n")
		private_key_path = input("Path to secure folder? ").replace("\ ", " ").rstrip()
		
		# Write the private key to disk
		try:
			pem_file_path = os.path.join(private_key_path, 'box.pem')
			
			if not os.path.exists(pem_file_path):
				pem_file = open(pem_file_path, 'x')
				pem_file.write(private_key_raw)
				pem_file.close()
				os.chmod(pem_file_path, 0o0400)
				print(f"{colors.BOLD}\nGenerated private key file at {pem_file_path}{colors.END}\n")
			else:
				print(f"{colors.BOLD}\nUsing existing private key file at {pem_file_path}{colors.END}\n")
				
			config['rsa_private_key_path'] = pem_file_path
			
		except Exception as error:
			raise SystemExit(f"{colors.RED}Unable to create private key file: {error}{colors.END}")
		
		# Write the config file to disk					
		try:
			with open('config.json', 'x') as json_file:
				json.dump(config, json_file)
				
			print(f"{colors.BOLD}Successfully created new config.json file.{colors.END}")
		except Exception as error:
			print(f"{colors.RED}Unable to create config file: {error}{colors.END}")
			
	return(config)
	
def box_auth(user_id, config):
	# Authenticate with the Box API
	auth = JWTAuth(
		client_id=config['clientID'],
		client_secret=config['clientSecret'],
		enterprise_id=config['enterpriseID'],
		jwt_key_id=config['publicKeyID'],
		rsa_private_key_passphrase=config['passphrase'],
		rsa_private_key_file_sys_path=config['rsa_private_key_path']
	)

	access_token = auth.authenticate_instance()
	
	client = Client(auth)
	user = client.user(user_id)
		
	return (client, user)

def update_log(result):
	now = f"[{time.strftime('%Y-%m-%d %I:%M:%S')}] "
	if upload_log:
		upload_log.write(f"{now}{result}\n")
		
		total_counts = sum(counts.values())
		
		if (total_counts > 0) and (total_counts % config['logBatch'] == 0):
			# Send the current log file to Box so that we get an in-progress view
			log = send_log_to_box(log_path, log_name, 1)
			print("Sent log file to Box.")
		
	print(f"{now}{result}")
	
def send_log_to_box(log_path, log_name, attempts):
	try:
		upload_the_log = log_folder.upload(log_path, log_name, upload_using_accelerator=True)
		result = f"\nUploaded log file '{log_name}' to Box."
	except BoxAPIException as error:
		if error.code == "item_name_in_use":
			# The file already exists, so let's upload a new version
			existing_id = error.context_info['conflicts']['id']
			existing_file = client.as_user(user).file(existing_id).get()
			update_file = existing_file.update_contents(log_path, upload_using_accelerator=True)
			result = f"\nUpdated log file '{log_name}' on Box."
		else:
			# Some other error thrown
			result = f"\nUnable to upload log: {error.message}"
	except ConnectionError as error:
		if attempts < config['maxAttempts']:
			attempts += 1
			print(f"I'm having trouble connecting. Attempt #{attempts} in {config['timeToWait']} seconds...")
			time.sleep(config['timeToWait'])
			result = send_log_to_box(log_path, log_name, attempts)
		else:
			result = f"Maximum number of retries reached while trying to upload: {log_name}"

	return(result)
	
def sanitize(sanitized_name):
	# Invalid characters and their corresponding replacements
	d_invalid_char_replace= { "/" : "_", "?": "X", "<": "(", ">": ")", "\\": "#", ":":"_", "*": "-", "|": "!", "\"" :""}
	
	for i, j in d_invalid_char_replace.items():
		sanitized_name = sanitized_name.replace(i, j)
	sanitized_name = sanitized_name.rstrip('. ') # strip periods and spaces from the end

	return sanitized_name
	
def count_files_and_folders(folder_path):
	count = 1 # count the parent folder

	for root, directories, files in os.walk(folder_path,topdown=True):
		for name in directories:
			current_path = os.path.join(root,name)
			
			if name.startswith('._'):
				ignored_files_and_folders.append(name)
		
			if any(ignored in current_path for ignored in ignored_files_and_folders):
				continue
			else:
				count += 1
			
		for name in files:
			current_path = os.path.join(root,name)
			
			if name.startswith('._'):
				ignored_files_and_folders.append(name)
		
			if any(ignored in current_path for ignored in ignored_files_and_folders):
				continue
			else:
				count += 1
				
		return(count)

def create_folder(current_path, folder_name, parent_id, attempts):
	try:
		new_folder = client.as_user(user).folder(parent_id).create_subfolder(folder_name)
		counts['folders_created'] += 1
		result = f"Folder '{current_path}' successfully created as '{folder_name}'"
		return(result, new_folder['id'])
	except BoxAPIException as error:
		if error.code == "item_name_in_use":
			try:
				existing_id = error.context_info['conflicts'][0]['id']
				existing_folder = client.as_user(user).folder(existing_id).get()
				result = f"Folder '{current_path}' already exists as '{folder_name}'"
				counts['folders_existing'] += 1
				return(result, existing_id)
			except Exception as error:
				counts['errors'] += 1
				result = f"{colors.RED}UNCAUGHT ERROR: {error}{colors.END}"
				return(result, None)
		elif error.code == "name_temporarily_reserved":
			if attempts < config['maxAttempts']:
				attempts += 1
				update_log(f"Name temporarily reserved. Attempt #{attempts} in {config['timeToWait']} seconds...")
				time.sleep(config['timeToWait'])
				result, folder_id = create_folder(current_path, folder_name, parent_id, attempts)
			else:
				counts['errors'] += 1
				result = f"{colors.RED}ERROR: Maximum number of retries reached while trying to create: {current_path}{colors.END}"
				folder_id = None
			return(result, folder_id)
			
		else:
			counts['errors'] += 1
			result = f"{colors.RED}ERROR: Unable to create '{current_path}': {error.message}{colors.END}"
			return(result, None)
	except ConnectionError as error:			
		if attempts < config['maxAttempts']:
			attempts += 1
			update_log(f"I'm having trouble connecting. Attempt #{attempts} in {config['timeToWait']} seconds...")
			time.sleep(config['timeToWait'])
			result, folder_id = create_folder(current_path, folder_name, parent_id, attempts)
		else:
			counts['errors'] += 1
			result = f"{colors.RED}ERROR: Maximum number of retries reached while trying to create: {current_path}{colors.END}"
			folder_id = None
		return(result, folder_id)
	except Exception as error:
		counts['errors'] += 1
		result = f"{colors.RED}UNCAUGHT ERROR: {error}{colors.END}"
		return(result, None)

def create_file(file_path, file_name, parent_id, attempts):
	root_folder = client.as_user(user).folder(parent_id)
	file_size_local = os.path.getsize(file_path)
	if file_size_local <= config["boxSizeLimitBytes"]:
		try:
			a_file = root_folder.upload(file_path, file_name, upload_using_accelerator=True)
			counts['files_uploaded'] += 1
			result = f"File '{file_path}' successfully created as '{file_name}'"
			return(result, a_file['id'])
		except BoxAPIException as error:
			if error.code == "item_name_in_use":
				existing_id = error.context_info['conflicts']['id']
				existing_file = client.as_user(user).file(existing_id).get()
				
				# Get the checksum for the local file
				local_file_checksum = hashlib.sha1(open(file_path, 'rb').read()).hexdigest()
											
				if existing_file['sha1'] == local_file_checksum:
					counts['files_existing'] += 1
					try:
						result = f"File '{file_path}' already exists as '{file_name}'"
					except Exception as error:
						result = f"{colors.RED}UNCAUGHT ERROR: {error}{colors.END}"
				else:
					try:
						# Either there is a partial upload or the file was modified, so let's upload a new version
						update_file = existing_file.update_contents(file_path, upload_using_accelerator=True)
						counts['files_existing'] += 1
						result = f"File '{file_path}' already existed as '{file_name}' but the checksum didn't match, so I updated it."
					except BoxAPIException as error:
						counts['errors'] += 1
						result = f"{colors.RED}ERROR: Unable to upload '{file_name}': {error.message}{colors.END}"
					except ConnectionError as error:
						if attempts < config['maxAttempts']:
							attempts += 1
							update_log(f"I'm having trouble connecting. Attempt #{attempts} in {config['timeToWait']} seconds...")
							time.sleep(config['timeToWait'])
							result, file_id = create_file(file_path, file_name, parent_id, attempts)
						else:
							counts['errors'] += 1
							result = f"{colors.RED}ERROR: Maximum number of retries reached while trying to create: {file_path}{colors.END}"
							file_id = None
						return(result, file_id)

				return(result, existing_id)
			elif error.code == "name_temporarily_reserved":
				if attempts < config['maxAttempts']:
					attempts += 1
					update_log(f"Name temporarily reserved. Attempt #{attempts} in {config['timeToWait']} seconds...")
					time.sleep(config['timeToWait'])
					result, file_id = create_file(file_path, file_name, parent_id, attempts)
				else:
					counts['errors'] += 1
					result = f"{colors.RED}ERROR: Maximum number of retries reached while trying to create: {file_path}{colors.END}"
					file_id = None
				return(result, folder_id)
			else:
				counts['errors'] += 1
				result = f"{colors.RED}ERROR: Unable to create '{file_name}': {error.message}{colors.END}"
				return(result, None)
		except ConnectionError as error:
			if attempts < config['maxAttempts']:
				attempts += 1
				update_log(f"I'm having trouble connecting. Attempt #{attempts} in {config['timeToWait']} seconds...")
				time.sleep(config['timeToWait'])
				result, file_id = create_file(file_path, file_name, parent_id, attempts)
			else:
				counts['errors'] += 1
				result = f"{colors.RED}ERROR: Maximum number of retries reached while trying to create: {file_path}{colors.END}"
				file_id = None
			return(result, file_id)
		except Exception as error:
			counts['errors'] += 1
			result = f"{colors.RED}UNCAUGHT ERROR: {error}{colors.END}"
			return(result, None)

	else:
		result = "File '{file_path}' is larger than {config['boxSizeLimitGB']}gb."
		counts['oversize'] += 1
		return(result, None)
		
def upload_to_box(s_input_folder, parent_id):
	folder_list = {0: {s_input_folder: parent_id}} # we'll use this to track the IDs for folders on Box
		
	for root, directories, files in os.walk(s_input_folder,topdown=True):
		for name in directories:
			current_path = os.path.join(root,name)
			
			if name.startswith('._'):
				ignored_files_and_folders.append(name)
			
			if any(ignored in current_path for ignored in ignored_files_and_folders):
				result = f"Folder '{current_path}' skipped."
				counts['skipped'] += 1
				update_log(result)
			else:
				parent_level = root.count(os.sep) - s_input_folder.count(os.sep)
				current_level = parent_level + 1
				try:
					parent_id = folder_list[parent_level][root]
					result, folder_id = create_folder(current_path, sanitize(name), parent_id, 1)
				except KeyError:
					counts['errors'] += 1
					result = f"{colors.RED}ERROR: I don't have an ID for this folder: {root}{colors.END}"
					folder_id = None
				
				if folder_id is not None:
					if current_level in folder_list.keys():
						folder_list[current_level].update({current_path: folder_id})
					else:
						folder_list[current_level] = {current_path: folder_id}
				
				update_log(result)
			
		for name in files:
			current_path = os.path.join(root,name)
			
			if name.startswith('._'):
				ignored_files_and_folders.append(name)
			
			if any(ignored in current_path for ignored in ignored_files_and_folders):
				result = f"File '{current_path}' skipped."
				counts['skipped'] += 1
				update_log(result)
			else:
				parent_level = root.count(os.sep) - s_input_folder.count(os.sep)
				current_level = parent_level + 1
				try:
					parent_id = folder_list[parent_level][root]
					result, file_id = create_file(current_path, sanitize(name), parent_id, 1)
				except KeyError:
					counts['errors'] += 1
					result = f"ERROR: I don't have a Parent ID for this file: {name}"
					file_id = None
				
				update_log(result)
		
		# after we go back up a level, forget the IDs for sub-folders						
		max_level = max(folder_list.keys())
		if max_level > current_level:
			folder_list.pop(max_level)
									
if __name__ == '__main__':

	global config
	config = get_config()
		
	if "uploader_id" not in globals():
		if config['appUsers'] is not None:
			list_of_users = ', '.join(str(key) for key in sorted(config['appUsers'].keys()))
		
			which_user = input(f"\nUploader to use? ({list_of_users}) ")
			try:
				uploader_id = config['appUsers'][which_user]
			except:
				raise SystemExit(f"\n{colors.RED}ERROR: Invalid uploader!{colors.END}")
		else:
			uploader_id = input("\nNo app users configured. What ID should I use for the uploader? ")

	try:
		client, user = box_auth(uploader_id, config)
		uploader_name = client.as_user(user).user().get()['name']
	except Exception as error:
		raise SystemExit(f"\n{colors.RED}ERROR: Box authentication failed: {str(error)}{colors.END}")
	
	print(f"\nUploader set to: {uploader_name}")
	
	log_folder = client.as_user(user).folder(config['logFileID'])
	logdir = (os.sep).join((os.path.dirname(os.path.abspath(__file__)), "logs"))
	
	if not os.path.exists(logdir):
		try:
			os.makedirs(logdir)
		except:
			raise SystemExit(f"\n{colors.RED}ERROR: Unable to create log folder!{colors.END}")
			
	if "target_folder_id" not in globals():
		target_folder_id = input("\nID for target folder on Box? ")
	
	try:
		target_folder_name = client.as_user(user).folder(target_folder_id).get()['name']
		print(f"\nTarget folder set to: {target_folder_name}")
	except:
		raise SystemExit(f"\n{colors.RED}ERROR: Invalid target folder ID!{colors.END}\n")
	
	if "s_input_folder" not in globals():
		s_input_folder = input("\nPath to local folder? ")
		s_input_folder = s_input_folder.replace("\ ", " ").rstrip()

	if os.path.isdir(s_input_folder):		
	
		top_level_name = sanitize(os.path.basename(s_input_folder))
		
		files_expected = count_files_and_folders(s_input_folder)
							
		start = time.time()
			
		summary = (
			f"Uploading from: {s_input_folder}\n" +
			f"To top-level folder: {top_level_name}\n" +
			f"Inside target folder: {target_folder_name}\n" +
			f"Number of files expected: {files_expected}\n" +
			f"Uploading as user: {uploader_name}\n"
		)
			
		time_stamp = time.strftime('%Y-%m-%d %H%M%S')
		log_name = f"{target_folder_name} - {top_level_name} - {uploader_name} - {time_stamp}.txt"
		log_path = (os.sep).join((logdir, log_name))
		
		try:
			upload_log = open(log_path, "a")
		except:
			raise SystemExit(f"{colors.RED}ERROR: Unable to write log file!{colors.END}")
			
		print(f"\n{summary}")
		upload_log.write(summary)
		
		try:
			# Create the top-level folder
			top_level_result, top_level_id = create_folder(s_input_folder, top_level_name, target_folder_id, 1)
		except:
			raise SystemExit(f"\n{colors.RED}ERROR: Unable to create top-level folder!{colors.END}\n")
		
		update_log(top_level_result)

		# Perform the recursive upload
		upload_to_box(s_input_folder, top_level_id)

		#Wrap everything up and finish off the log file
		total_files = sum(counts.values()) - counts['skipped']
		
		all_counts = (
			f"\nFiles uploaded: {counts['files_uploaded']}" +
			f"\nExisting files: {counts['files_existing']}" +
			f"\nFolders created: {counts['folders_created']}" +
			f"\nExisting folders: {counts['folders_existing']}" +
			f"\nSkipped: {counts['skipped']}" +
			f"\nFiles larger than {config['boxSizeLimitGB']}gb: {counts['oversize']}" +
			f"\nErrors: {counts['errors']}" +
			f"\n\nFiles and Folders Expected: {files_expected}" +
			f"\nTotal Files and Folders Processed: {str(total_files)}"
		)
			
		if int(files_expected) != total_files:
			all_counts = (f"{all_counts}\n\n{colors.RED}WARNING: FILE COUNTS DO NOT MATCH!{colors.END}\n")

		print(all_counts)
		upload_log.write(all_counts)

		elapsed = f"\nTime elapsed: {datetime.timedelta(seconds=(time.time() - start))}"
		print(elapsed)
		upload_log.write(elapsed)
		
		upload_log.close()

		# Upload the log file to Box
		result = send_log_to_box(log_path, log_name, 1)

		print(result)
	else:
		raise SystemExit(f"\n{colors.RED}ERROR: Unable to locate folder: {s_input_folder}{colors.END}\n")